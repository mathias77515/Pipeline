<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lib package &mdash; QUBIC Simulation Pipelines 0.8 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=a0e24af7"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            QUBIC Simulation Pipelines
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">src</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">QUBIC Simulation Pipelines</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">lib package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/lib.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="lib-package">
<h1>lib package<a class="headerlink" href="#lib-package" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-lib.Qacquisition">
<span id="lib-qacquisition-module"></span><h2>lib.Qacquisition module<a class="headerlink" href="#module-lib.Qacquisition" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.JointAcquisitionComponentsMapMaking">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">JointAcquisitionComponentsMapMaking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nsub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nus_external</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nintegr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_co</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#JointAcquisitionComponentsMapMaking"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.JointAcquisitionComponentsMapMaking" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>get_invntt_operator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_operator</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.JointAcquisitionComponentsMapMaking.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#JointAcquisitionComponentsMapMaking.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.JointAcquisitionComponentsMapMaking.get_invntt_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.JointAcquisitionComponentsMapMaking.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_co</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#JointAcquisitionComponentsMapMaking.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.JointAcquisitionComponentsMapMaking.get_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.JointAcquisitionFrequencyMapMaking">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">JointAcquisitionFrequencyMapMaking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nsub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#JointAcquisitionFrequencyMapMaking"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.JointAcquisitionFrequencyMapMaking" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>get_invntt_operator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_operator</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.JointAcquisitionFrequencyMapMaking.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight_planck</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seenpix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#JointAcquisitionFrequencyMapMaking.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.JointAcquisitionFrequencyMapMaking.get_invntt_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.JointAcquisitionFrequencyMapMaking.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seenpix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#JointAcquisitionFrequencyMapMaking.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.JointAcquisitionFrequencyMapMaking.get_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.OtherDataParametric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">OtherDataParametric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nside</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nintegr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#OtherDataParametric"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.OtherDataParametric" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>get_invntt_operator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_noise</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_operator</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.OtherDataParametric.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#OtherDataParametric.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.OtherDataParametric.get_invntt_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.OtherDataParametric.get_noise">
<span class="sig-name descname"><span class="pre">get_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seenpix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#OtherDataParametric.get_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.OtherDataParametric.get_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.OtherDataParametric.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">myfwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_co</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#OtherDataParametric.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.OtherDataParametric.get_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.PlanckAcquisition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">PlanckAcquisition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">band</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#PlanckAcquisition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.PlanckAcquisition" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>get_invntt_operator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_map</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_noise</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_operator</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.PlanckAcquisition.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beam_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seenpix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#PlanckAcquisition.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.PlanckAcquisition.get_invntt_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.PlanckAcquisition.get_map">
<span class="sig-name descname"><span class="pre">get_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nintegr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sky_config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#PlanckAcquisition.get_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.PlanckAcquisition.get_map" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.PlanckAcquisition.get_noise">
<span class="sig-name descname"><span class="pre">get_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#PlanckAcquisition.get_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.PlanckAcquisition.get_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.PlanckAcquisition.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nintegr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#PlanckAcquisition.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.PlanckAcquisition.get_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">QubicAcquisition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instrument</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Acquisition</span></code></p>
<p>The QubicAcquisition class, which combines the instrument, sampling and
scene models.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_add_grids_operator" title="lib.Qacquisition.QubicAcquisition.get_add_grids_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_add_grids_operator</span></code></a>()</p></td>
<td><p>Return operator to add signal from detector pairs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_aperture_integration_operator" title="lib.Qacquisition.QubicAcquisition.get_aperture_integration_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_aperture_integration_operator</span></code></a>()</p></td>
<td><p>Integrate flux density in the telescope aperture.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_convolution_peak_operator" title="lib.Qacquisition.QubicAcquisition.get_convolution_peak_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_convolution_peak_operator</span></code></a>(**keywords)</p></td>
<td><p>Return an operator that convolves the Healpix sky by the gaussian kernel that, if used in conjonction with the peak sampling operator, best approximates the synthetic beam.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_coverage" title="lib.Qacquisition.QubicAcquisition.get_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coverage</span></code></a>()</p></td>
<td><p>Return the acquisition scene coverage as given by H.T(1), normalized so that its integral over the sky is the number of detectors times the duration of the acquisition.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_detector_integration_operator" title="lib.Qacquisition.QubicAcquisition.get_detector_integration_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_detector_integration_operator</span></code></a>()</p></td>
<td><p>Integrate flux density in detector solid angles.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_detector_response_operator" title="lib.Qacquisition.QubicAcquisition.get_detector_response_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_detector_response_operator</span></code></a>()</p></td>
<td><p>Return the operator for the bolometer responses.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_distribution_operator" title="lib.Qacquisition.QubicAcquisition.get_distribution_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_distribution_operator</span></code></a>()</p></td>
<td><p>Return the MPI distribution operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_filter_operator" title="lib.Qacquisition.QubicAcquisition.get_filter_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_filter_operator</span></code></a>()</p></td>
<td><p>Return the filter operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_hitmap" title="lib.Qacquisition.QubicAcquisition.get_hitmap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_hitmap</span></code></a>([nside])</p></td>
<td><p>Return a healpy map whose values are the number of times a pointing hits the pixel.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_hwp_operator" title="lib.Qacquisition.QubicAcquisition.get_hwp_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_hwp_operator</span></code></a>()</p></td>
<td><p>Return the operator for the bolometer responses.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_invntt_operator" title="lib.Qacquisition.QubicAcquisition.get_invntt_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_invntt_operator</span></code></a>(det_noise, photon_noise)</p></td>
<td><p>Return the inverse time-time noise correlation matrix as an Operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_noise" title="lib.Qacquisition.QubicAcquisition.get_noise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_noise</span></code></a>(det_noise, photon_noise[, seed, out])</p></td>
<td><p>Return the noise realization according the instrument's noise model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_observation" title="lib.Qacquisition.QubicAcquisition.get_observation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_observation</span></code></a>(map[, convolution, noiseless])</p></td>
<td><p>tod = map2tod(acquisition, map) tod, convolved_map = map2tod(acquisition, map, convolution=True) :param map: Temperature, QU or IQU maps of shapes npix, (npix, 2), (npix, 3)             with npix = 12 * nside**2 :type map: I, QU or IQU maps :param noiseless: If True, no noise is added to the observation. :type noiseless: boolean, optional :param convolution: Set to True to convolve the input map by a gaussian and return it. :type convolution: boolean, optional.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_operator" title="lib.Qacquisition.QubicAcquisition.get_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator</span></code></a>()</p></td>
<td><p>Return the operator of the acquisition.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator_nbytes</span></code>()</p></td>
<td><p>Return the number of bytes required to store the acquisition model as an operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_polarizer_operator" title="lib.Qacquisition.QubicAcquisition.get_polarizer_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_polarizer_operator</span></code></a>()</p></td>
<td><p>Return operator for the polarizer grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_projection_operator" title="lib.Qacquisition.QubicAcquisition.get_projection_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_projection_operator</span></code></a>([verbose])</p></td>
<td><p>Return the projection operator for the peak sampling.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_subtract_grids_operator" title="lib.Qacquisition.QubicAcquisition.get_subtract_grids_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_subtract_grids_operator</span></code></a>()</p></td>
<td><p>Return operator to subtract signal from detector pairs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicAcquisition.get_unit_conversion_operator" title="lib.Qacquisition.QubicAcquisition.get_unit_conversion_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_unit_conversion_operator</span></code></a>()</p></td>
<td><p>Convert sky temperature into W / m^2 / Hz.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pack</span></code>(x[, out, copy])</p></td>
<td><p>Convert a multi-dimensional array into a 1-dimensional array which only includes the selected components, potentially ordered according to a given ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>([map, header, new_figure, percentile])</p></td>
<td><p>map : ndarray of dim 2</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unpack</span></code>(x[, out, missing_value, copy])</p></td>
<td><p>Convert a 1-dimensional array into a multi-dimensional array which includes the non-selected components, mimicking the multi-dimensional layout.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>get_diag_invntt_operator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_preconditioner</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_add_grids_operator">
<span class="sig-name descname"><span class="pre">get_add_grids_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_add_grids_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_add_grids_operator" title="Link to this definition"></a></dt>
<dd><p>Return operator to add signal from detector pairs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_aperture_integration_operator">
<span class="sig-name descname"><span class="pre">get_aperture_integration_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_aperture_integration_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_aperture_integration_operator" title="Link to this definition"></a></dt>
<dd><p>Integrate flux density in the telescope aperture.
Convert signal from W / m^2 / Hz into W / Hz.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_convolution_peak_operator">
<span class="sig-name descname"><span class="pre">get_convolution_peak_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_convolution_peak_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_convolution_peak_operator" title="Link to this definition"></a></dt>
<dd><p>Return an operator that convolves the Healpix sky by the gaussian
kernel that, if used in conjonction with the peak sampling operator,
best approximates the synthetic beam.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_coverage">
<span class="sig-name descname"><span class="pre">get_coverage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_coverage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_coverage" title="Link to this definition"></a></dt>
<dd><p>Return the acquisition scene coverage as given by H.T(1), normalized
so that its integral over the sky is the number of detectors times
the duration of the acquisition.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_detector_integration_operator">
<span class="sig-name descname"><span class="pre">get_detector_integration_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_detector_integration_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_detector_integration_operator" title="Link to this definition"></a></dt>
<dd><p>Integrate flux density in detector solid angles.
Convert W / sr into W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_detector_response_operator">
<span class="sig-name descname"><span class="pre">get_detector_response_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_detector_response_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_detector_response_operator" title="Link to this definition"></a></dt>
<dd><p>Return the operator for the bolometer responses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_diag_invntt_operator">
<span class="sig-name descname"><span class="pre">get_diag_invntt_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_diag_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_diag_invntt_operator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_distribution_operator">
<span class="sig-name descname"><span class="pre">get_distribution_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_distribution_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_distribution_operator" title="Link to this definition"></a></dt>
<dd><p>Return the MPI distribution operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_filter_operator">
<span class="sig-name descname"><span class="pre">get_filter_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_filter_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_filter_operator" title="Link to this definition"></a></dt>
<dd><p>Return the filter operator.
Convert units from W/Hz to W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_hitmap">
<span class="sig-name descname"><span class="pre">get_hitmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nside</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_hitmap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_hitmap" title="Link to this definition"></a></dt>
<dd><p>Return a healpy map whose values are the number of times a pointing
hits the pixel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_hwp_operator">
<span class="sig-name descname"><span class="pre">get_hwp_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_hwp_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_hwp_operator" title="Link to this definition"></a></dt>
<dd><p>Return the operator for the bolometer responses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">det_noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">photon_noise</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_invntt_operator" title="Link to this definition"></a></dt>
<dd><p>Return the inverse time-time noise correlation matrix as an Operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_noise">
<span class="sig-name descname"><span class="pre">get_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">det_noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">photon_noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_noise" title="Link to this definition"></a></dt>
<dd><p>Return the noise realization according the instrument’s noise model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>out</strong> (<em>ndarray</em><em>, </em><em>optional</em>) – Placeholder for the output noise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_observation">
<span class="sig-name descname"><span class="pre">get_observation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noiseless</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_observation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_observation" title="Link to this definition"></a></dt>
<dd><p>tod = map2tod(acquisition, map)
tod, convolved_map = map2tod(acquisition, map, convolution=True)
:param map: Temperature, QU or IQU maps of shapes npix, (npix, 2), (npix, 3)</p>
<blockquote>
<div><p>with npix = 12 * nside**2</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noiseless</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If True, no noise is added to the observation.</p></li>
<li><p><strong>convolution</strong> (<em>boolean</em><em>, </em><em>optional</em>) – Set to True to convolve the input map by a gaussian and return it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>tod</strong> (<em>array</em>) – The Time-Ordered-Data of shape (ndetectors, ntimes).</p></li>
<li><p><strong>convolved_map</strong> (<em>array, optional</em>) – The convolved map, if the convolution keyword is set.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_operator" title="Link to this definition"></a></dt>
<dd><p>Return the operator of the acquisition. Note that the operator is only
linear if the scene temperature is differential (absolute=False).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_polarizer_operator">
<span class="sig-name descname"><span class="pre">get_polarizer_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_polarizer_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_polarizer_operator" title="Link to this definition"></a></dt>
<dd><p>Return operator for the polarizer grid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_preconditioner">
<span class="sig-name descname"><span class="pre">get_preconditioner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cov</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_preconditioner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_preconditioner" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_projection_operator">
<span class="sig-name descname"><span class="pre">get_projection_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_projection_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_projection_operator" title="Link to this definition"></a></dt>
<dd><p>Return the projection operator for the peak sampling.
Convert units from W to W/sr.
:param verbose: If true, display information about the memory allocation.
:type verbose: bool, optional</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_subtract_grids_operator">
<span class="sig-name descname"><span class="pre">get_subtract_grids_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_subtract_grids_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_subtract_grids_operator" title="Link to this definition"></a></dt>
<dd><p>Return operator to subtract signal from detector pairs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicAcquisition.get_unit_conversion_operator">
<span class="sig-name descname"><span class="pre">get_unit_conversion_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicAcquisition.get_unit_conversion_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicAcquisition.get_unit_conversion_operator" title="Link to this definition"></a></dt>
<dd><p>Convert sky temperature into W / m^2 / Hz.
If the scene has been initialised with the ‘absolute’ keyword, the
scene is assumed to include the CMB background and the fluctuations
(in Kelvin) and the operator follows the non-linear Planck law.
Otherwise, the scene only includes the fluctuations (in microKelvin)
and the operator is linear (i.e. the output also corresponds to power
fluctuations).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicDualBand">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">QubicDualBand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_co</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicDualBand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicDualBand" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qacquisition.QubicMultiAcquisitions" title="lib.Qacquisition.QubicMultiAcquisitions"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubicMultiAcquisitions</span></code></a></p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicDualBand.get_invntt_operator" title="lib.Qacquisition.QubicDualBand.get_invntt_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_invntt_operator</span></code></a>()</p></td>
<td><p>Method to compute the inverse noise covariance matrix in time-domain.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicDualBand.get_operator" title="lib.Qacquisition.QubicDualBand.get_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator</span></code></a>([A, gain, fwhm, seenpix])</p></td>
<td><p>Method to generate the pointing matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicDualBand.sum_over_band" title="lib.Qacquisition.QubicDualBand.sum_over_band"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum_over_band</span></code></a>(h, algo[, gain])</p></td>
<td><p>Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicDualBand.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicDualBand.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicDualBand.get_invntt_operator" title="Link to this definition"></a></dt>
<dd><p>Method to compute the inverse noise covariance matrix in time-domain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicDualBand.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seenpix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicDualBand.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicDualBand.get_operator" title="Link to this definition"></a></dt>
<dd><p>Method to generate the pointing matrix.</p>
<dl class="simple">
<dt>mixing_matrix<span class="classifier">array like containing mixing matrix elements. If the elements of the mixing matrix are constant across the sky,</span></dt><dd><p>mixing_matrix.shape = (nfreq, ncomp)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicDualBand.sum_over_band">
<span class="sig-name descname"><span class="pre">sum_over_band</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicDualBand.sum_over_band"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicDualBand.sum_over_band" title="Link to this definition"></a></dt>
<dd><p>Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicFullBandSystematic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">QubicFullBandSystematic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nsub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_co</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effective_duration150</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effective_duration220</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicFullBandSystematic"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicFullBandSystematic" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qacquisition.QubicPolyAcquisition" title="lib.Qacquisition.QubicPolyAcquisition"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubicPolyAcquisition</span></code></a></p>
<p>Instance to compute QUBIC operator.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicFullBandSystematic.get_PySM_maps" title="lib.Qacquisition.QubicFullBandSystematic.get_PySM_maps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_PySM_maps</span></code></a>(config[, r, Alens])</p></td>
<td><p>Read configuration dictionary which contains every components adn the model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicFullBandSystematic.get_components_operator" title="lib.Qacquisition.QubicFullBandSystematic.get_components_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_components_operator</span></code></a>(beta, nu[, Amm, active])</p></td>
<td><p>Create a mixing matrix operator for a given value of spectral index</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coverage</span></code>()</p></td>
<td><p>Return an array of monochromatic coverage maps, one for each of subacquisitions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coverage_mask</span></code>(coverages[, covlim])</p></td>
<td><p>Return a healpix boolean map with True on the pixels where ALL the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicFullBandSystematic.get_hwp_operator" title="lib.Qacquisition.QubicFullBandSystematic.get_hwp_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_hwp_operator</span></code></a>(angle_hwp)</p></td>
<td><p>Return the rotation matrix for the half-wave plate.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicFullBandSystematic.get_invntt_operator" title="lib.Qacquisition.QubicFullBandSystematic.get_invntt_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_invntt_operator</span></code></a>()</p></td>
<td><p>Method to compute the inverse noise covariance matrix in time-domain.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicFullBandSystematic.get_operator" title="lib.Qacquisition.QubicFullBandSystematic.get_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator</span></code></a>([beta, Amm, angle_hwp, gain, fwhm])</p></td>
<td><p>Return an sum of operators for subacquisitions</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator_to_make_TOD</span></code>()</p></td>
<td><p>Return a BlockRowOperator of subacquisition operators In polychromatic mode it is only applied to produce the TOD To reconstruct maps one should use the get_operator function</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicFullBandSystematic.sum_over_band" title="lib.Qacquisition.QubicFullBandSystematic.sum_over_band"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum_over_band</span></code></a>(h[, gain])</p></td>
<td><p>Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">warnings</span></code>(d)</p></td>
<td><p>This method prevent to you that beam is not a good approximation in the 220 GHz band.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>get_noise</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicFullBandSystematic.get_PySM_maps">
<span class="sig-name descname"><span class="pre">get_PySM_maps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Alens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicFullBandSystematic.get_PySM_maps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicFullBandSystematic.get_PySM_maps" title="Link to this definition"></a></dt>
<dd><p>Read configuration dictionary which contains every components adn the model.</p>
<p>Example : d = {‘cmb’:42, ‘dust’:’d0’, ‘synchrotron’:’s0’}</p>
<p>The CMB is randomly generated fram specific seed. Astrophysical foregrounds come from PySM 3.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicFullBandSystematic.get_components_operator">
<span class="sig-name descname"><span class="pre">get_components_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Amm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicFullBandSystematic.get_components_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicFullBandSystematic.get_components_operator" title="Link to this definition"></a></dt>
<dd><p>Create a mixing matrix operator for a given value of spectral index</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicFullBandSystematic.get_hwp_operator">
<span class="sig-name descname"><span class="pre">get_hwp_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angle_hwp</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicFullBandSystematic.get_hwp_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicFullBandSystematic.get_hwp_operator" title="Link to this definition"></a></dt>
<dd><p>Return the rotation matrix for the half-wave plate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicFullBandSystematic.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicFullBandSystematic.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicFullBandSystematic.get_invntt_operator" title="Link to this definition"></a></dt>
<dd><p>Method to compute the inverse noise covariance matrix in time-domain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicFullBandSystematic.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Amm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle_hwp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicFullBandSystematic.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicFullBandSystematic.get_operator" title="Link to this definition"></a></dt>
<dd><p>Return an sum of operators for subacquisitions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicFullBandSystematic.sum_over_band">
<span class="sig-name descname"><span class="pre">sum_over_band</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicFullBandSystematic.sum_over_band"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicFullBandSystematic.sum_over_band" title="Link to this definition"></a></dt>
<dd><p>Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicIntegrated">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">QubicIntegrated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nsub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nrec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicIntegrated"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicIntegrated" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qacquisition.QubicPolyAcquisition" title="lib.Qacquisition.QubicPolyAcquisition"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubicPolyAcquisition</span></code></a></p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicIntegrated.get_TOD" title="lib.Qacquisition.QubicIntegrated.get_TOD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_TOD</span></code></a>(skyconfig, beta[, convolution, ...])</p></td>
<td><p>Method which allow to compute QUBIC TOD for a given skyconfig according to a given beta.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicIntegrated.get_coverage" title="lib.Qacquisition.QubicIntegrated.get_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coverage</span></code></a>()</p></td>
<td><p>Return an array of monochromatic coverage maps, one for each of subacquisitions</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coverage_mask</span></code>(coverages[, covlim])</p></td>
<td><p>Return a healpix boolean map with True on the pixels where ALL the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicIntegrated.get_invntt_operator" title="lib.Qacquisition.QubicIntegrated.get_invntt_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_invntt_operator</span></code></a>(det_noise, photon_noise)</p></td>
<td><p>Return the inverse noise covariance matrix as operator</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicIntegrated.get_noise" title="lib.Qacquisition.QubicIntegrated.get_noise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_noise</span></code></a>(det_noise, photon_noise[, seed])</p></td>
<td><p>Method which compute the noise of QUBIC.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicIntegrated.get_operator" title="lib.Qacquisition.QubicIntegrated.get_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator</span></code></a>([convolution, myfwhm])</p></td>
<td><p>Return an sum of operators for subacquisitions</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator_to_make_TOD</span></code>()</p></td>
<td><p>Return a BlockRowOperator of subacquisition operators In polychromatic mode it is only applied to produce the TOD To reconstruct maps one should use the get_operator function</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">warnings</span></code>(d)</p></td>
<td><p>This method prevent to you that beam is not a good approximation in the 220 GHz band.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>bandpass_correction</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicIntegrated.bandpass_correction">
<span class="sig-name descname"><span class="pre">bandpass_correction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tod</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicIntegrated.bandpass_correction"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicIntegrated.bandpass_correction" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicIntegrated.get_TOD">
<span class="sig-name descname"><span class="pre">get_TOD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">skyconfig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">myfwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandpass_correction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicIntegrated.get_TOD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicIntegrated.get_TOD" title="Link to this definition"></a></dt>
<dd><p>Method which allow to compute QUBIC TOD for a given skyconfig according to a given beta.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicIntegrated.get_coverage">
<span class="sig-name descname"><span class="pre">get_coverage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicIntegrated.get_coverage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicIntegrated.get_coverage" title="Link to this definition"></a></dt>
<dd><p>Return an array of monochromatic coverage maps, one for each of subacquisitions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicIntegrated.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">det_noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">photon_noise</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicIntegrated.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicIntegrated.get_invntt_operator" title="Link to this definition"></a></dt>
<dd><p>Return the inverse noise covariance matrix as operator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicIntegrated.get_noise">
<span class="sig-name descname"><span class="pre">get_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">det_noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">photon_noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicIntegrated.get_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicIntegrated.get_noise" title="Link to this definition"></a></dt>
<dd><p>Method which compute the noise of QUBIC.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicIntegrated.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">myfwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicIntegrated.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicIntegrated.get_operator" title="Link to this definition"></a></dt>
<dd><p>Return an sum of operators for subacquisitions</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicMultiAcquisitions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">QubicMultiAcquisitions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_co</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicMultiAcquisitions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicMultiAcquisitions" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Instance to define the multi-frequency instrument.</p>
<dl class="simple">
<dt>Input<span class="classifier">- dictionary</span><span class="classifier">contains QUBIC informations</span></dt><dd><ul class="simple">
<li><p>Nsub : Number of sub-bands for integrating the physical bandwidth</p></li>
<li><p>Nrec : Number of reconstructed maps (in the case of FMM)</p></li>
<li><p>comps : List of astrophysical components (CMB, Dust, …)</p></li>
<li><p>H : List of pointing matrix if not already computed</p></li>
<li><p>nu_co : Frequency of a line emission</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicPolyAcquisition">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">QubicPolyAcquisition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multiinstrument</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicPolyAcquisition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicPolyAcquisition" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicPolyAcquisition.get_coverage" title="lib.Qacquisition.QubicPolyAcquisition.get_coverage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coverage</span></code></a>()</p></td>
<td><p>Return an array of monochromatic coverage maps, one for each of subacquisitions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicPolyAcquisition.get_coverage_mask" title="lib.Qacquisition.QubicPolyAcquisition.get_coverage_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_coverage_mask</span></code></a>(coverages[, covlim])</p></td>
<td><p>Return a healpix boolean map with True on the pixels where ALL the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicPolyAcquisition.get_invntt_operator" title="lib.Qacquisition.QubicPolyAcquisition.get_invntt_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_invntt_operator</span></code></a>()</p></td>
<td><p>Return the inverse noise covariance matrix as operator</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicPolyAcquisition.get_operator" title="lib.Qacquisition.QubicPolyAcquisition.get_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator</span></code></a>()</p></td>
<td><p>Return an sum of operators for subacquisitions</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicPolyAcquisition.get_operator_to_make_TOD" title="lib.Qacquisition.QubicPolyAcquisition.get_operator_to_make_TOD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator_to_make_TOD</span></code></a>()</p></td>
<td><p>Return a BlockRowOperator of subacquisition operators In polychromatic mode it is only applied to produce the TOD To reconstruct maps one should use the get_operator function</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicPolyAcquisition.warnings" title="lib.Qacquisition.QubicPolyAcquisition.warnings"><code class="xref py py-obj docutils literal notranslate"><span class="pre">warnings</span></code></a>(d)</p></td>
<td><p>This method prevent to you that beam is not a good approximation in the 220 GHz band.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>get_noise</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicPolyAcquisition.get_coverage">
<span class="sig-name descname"><span class="pre">get_coverage</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicPolyAcquisition.get_coverage"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicPolyAcquisition.get_coverage" title="Link to this definition"></a></dt>
<dd><p>Return an array of monochromatic coverage maps, one for each of subacquisitions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicPolyAcquisition.get_coverage_mask">
<span class="sig-name descname"><span class="pre">get_coverage_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coverages</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covlim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicPolyAcquisition.get_coverage_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicPolyAcquisition.get_coverage_mask" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Return a healpix boolean map with True on the pixels where ALL the</dt><dd><p>subcoverages are above covlim * subcoverage.max()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicPolyAcquisition.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicPolyAcquisition.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicPolyAcquisition.get_invntt_operator" title="Link to this definition"></a></dt>
<dd><p>Return the inverse noise covariance matrix as operator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicPolyAcquisition.get_noise">
<span class="sig-name descname"><span class="pre">get_noise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicPolyAcquisition.get_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicPolyAcquisition.get_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicPolyAcquisition.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicPolyAcquisition.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicPolyAcquisition.get_operator" title="Link to this definition"></a></dt>
<dd><p>Return an sum of operators for subacquisitions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicPolyAcquisition.get_operator_to_make_TOD">
<span class="sig-name descname"><span class="pre">get_operator_to_make_TOD</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicPolyAcquisition.get_operator_to_make_TOD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicPolyAcquisition.get_operator_to_make_TOD" title="Link to this definition"></a></dt>
<dd><p>Return a BlockRowOperator of subacquisition operators
In polychromatic mode it is only applied to produce the TOD
To reconstruct maps one should use the get_operator function</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicPolyAcquisition.warnings">
<span class="sig-name descname"><span class="pre">warnings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicPolyAcquisition.warnings"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicPolyAcquisition.warnings" title="Link to this definition"></a></dt>
<dd><p>This method prevent to you that beam is not a good
approximation in the 220 GHz band.
Also can be used to add new warnings when acquisition is created in
specific configuration.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicUltraWideBand">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">QubicUltraWideBand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrec</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_co</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicUltraWideBand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicUltraWideBand" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qacquisition.QubicMultiAcquisitions" title="lib.Qacquisition.QubicMultiAcquisitions"><code class="xref py py-class docutils literal notranslate"><span class="pre">QubicMultiAcquisitions</span></code></a></p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicUltraWideBand.get_invntt_operator" title="lib.Qacquisition.QubicUltraWideBand.get_invntt_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_invntt_operator</span></code></a>()</p></td>
<td><p>Method to compute the inverse noise covariance matrix in time-domain.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicUltraWideBand.get_operator" title="lib.Qacquisition.QubicUltraWideBand.get_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator</span></code></a>([A, gain, fwhm])</p></td>
<td><p>Method to generate the pointing matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qacquisition.QubicUltraWideBand.sum_over_band" title="lib.Qacquisition.QubicUltraWideBand.sum_over_band"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum_over_band</span></code></a>(h, algo[, gain])</p></td>
<td><p>Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicUltraWideBand.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicUltraWideBand.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicUltraWideBand.get_invntt_operator" title="Link to this definition"></a></dt>
<dd><p>Method to compute the inverse noise covariance matrix in time-domain.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicUltraWideBand.get_operator">
<span class="sig-name descname"><span class="pre">get_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicUltraWideBand.get_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicUltraWideBand.get_operator" title="Link to this definition"></a></dt>
<dd><p>Method to generate the pointing matrix.</p>
<dl class="simple">
<dt>mixing_matrix<span class="classifier">array like containing mixing matrix elements. If the elements of the mixing matrix are constant across the sky,</span></dt><dd><p>mixing_matrix.shape = (nfreq, ncomp)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qacquisition.QubicUltraWideBand.sum_over_band">
<span class="sig-name descname"><span class="pre">sum_over_band</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#QubicUltraWideBand.sum_over_band"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.QubicUltraWideBand.sum_over_band" title="Link to this definition"></a></dt>
<dd><p>Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lib.Qacquisition.arcmin2rad">
<span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">arcmin2rad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arcmin</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#arcmin2rad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.arcmin2rad" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lib.Qacquisition.create_array">
<span class="sig-prename descclassname"><span class="pre">lib.Qacquisition.</span></span><span class="sig-name descname"><span class="pre">create_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nside</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qacquisition.html#create_array"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qacquisition.create_array" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-lib.Qcg">
<span id="lib-qcg-module"></span><h2>lib.Qcg module<a class="headerlink" href="#module-lib.Qcg" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="lib.Qcg.pcg">
<span class="sig-prename descclassname"><span class="pre">lib.Qcg.</span></span><span class="sig-name descname"><span class="pre">pcg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reuse_initial_state</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcg.html#pcg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcg.pcg" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>{Operator</em><em>, </em><em>sparse matrix</em><em>, </em><em>dense matrix}</em>) – The real or complex N-by-N matrix of the linear system
<code class="docutils literal notranslate"><span class="pre">A</span></code> must represent a hermitian, positive definite matrix</p></li>
<li><p><strong>b</strong> (<em>{array</em><em>, </em><em>matrix}</em>) – Right hand side of the linear system. Has shape (N,) or (N,1).</p></li>
<li><p><strong>x0</strong> (<em>{array</em><em>, </em><em>matrix}</em>) – Starting guess for the solution.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance to achieve. The algorithm terminates when either the
relative residual is below <cite>tol</cite>.</p></li>
<li><p><strong>maxiter</strong> (<em>integer</em><em>, </em><em>optional</em>) – Maximum number of iterations.  Iteration will stop after maxiter
steps even if the specified tolerance has not been achieved.</p></li>
<li><p><strong>M</strong> (<em>{Operator</em><em>, </em><em>sparse matrix</em><em>, </em><em>dense matrix}</em><em>, </em><em>optional</em>) – Preconditioner for A.  The preconditioner should approximate the
inverse of A.  Effective preconditioning dramatically improves the
rate of convergence, which implies that fewer iterations are needed
to reach a given error tolerance.</p></li>
<li><p><strong>disp</strong> (<em>boolean</em>) – Set to True to display convergence message</p></li>
<li><p><strong>callback</strong> (<em>function</em><em>, </em><em>optional</em>) – User-supplied function to call after each iteration.  It is called
as callback(self), where self is an instance of this class.</p></li>
<li><p><strong>reuse_initial_state</strong> (<em>boolean</em><em>, </em><em>optional</em>) – If set to True, the buffer initial guess (if provided) is reused
during the iterations. Beware of side effects!</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>output</strong> – ‘x’ : the converged solution.
‘success’ : boolean indicating success
‘message’ : string indicating cause of failure
‘nit’ : number of completed iterations
‘error’ : normalized residual ||Ax-b|| / ||b||
‘time’ : elapsed time in solver
‘algorithm’ : the PCGAlgorithm instance (the callback function has</p>
<blockquote>
<div><p>access to it and can store information in it)</p>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict whose keys are</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-lib.Qcomponent_model">
<span id="lib-qcomponent-model-module"></span><h2>lib.Qcomponent_model module<a class="headerlink" href="#module-lib.Qcomponent_model" title="Link to this heading"></a></h2>
<p>Parametric spectral energy distribution (SED)</p>
<p>Unified API for evaluating SEDs, see <a class="reference internal" href="#lib.Qcomponent_model.Component" title="lib.Qcomponent_model.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a>.</p>
<p>This module also provides a handy way of generating a <a class="reference internal" href="#lib.Qcomponent_model.Component" title="lib.Qcomponent_model.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a> from
analytic expressions, see the <a class="reference internal" href="#lib.Qcomponent_model.AnalyticComponent" title="lib.Qcomponent_model.AnalyticComponent"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticComponent</span></code></a>. For components
frequently used (e.g. power law, gray body, CMB) these are already
prepared.</p>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.AnalyticComponent">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">AnalyticComponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">analytic_expr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">fixed_params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#AnalyticComponent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.AnalyticComponent" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qcomponent_model.Component" title="lib.Qcomponent_model.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a></p>
<p>Component defined analytically</p>
<p>Class that allows analytic definition and automatic (symbolic)
differentiation of it using <a class="reference external" href="https://docs.sympy.org/latest/modules/functions/index.html">sympy</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>analytic_expr</strong> (<em>str</em>) – Analytic expression for the SED. The variable representing the
frequency is assumed to be <code class="docutils literal notranslate"><span class="pre">nu</span></code>. You can not use names that produce
clashes with <a class="reference external" href="https://docs.sympy.org/latest/modules/functions/index.html">sympy</a> definitions (e.g, <a class="reference external" href="https://docs.sympy.org/latest/modules/functions/index.html">functions</a>).
Notable forbidden names are <em>beta</em>, <em>gamma</em>.</p></li>
<li><p><strong>**fixed_params</strong> (<em>float</em>) – Fix the value of the desired variables. If a variable is not specified
or is set equal to <code class="docutils literal notranslate"><span class="pre">None</span></code>, it will be a free parameters.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Difference with respect to a <cite>sympy.Expression</cite></p>
<ul class="simple">
<li><p>Efficient evaluators of the SED and its derivatives are prepared at
construction time</p></li>
<li><p>Following the API specified in <a class="reference internal" href="#lib.Qcomponent_model.Component" title="lib.Qcomponent_model.Component"><code class="xref py py-class docutils literal notranslate"><span class="pre">Component</span></code></a>, <code class="docutils literal notranslate"><span class="pre">nu</span></code> has a special
meaning and has a dedicated dimension (the last one) when evaluations are
performed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">diff</span></code> (and <code class="docutils literal notranslate"><span class="pre">diff_diff</span></code>) return the evaluation of the derivatives with
respect to all the free parameters, not the expression of the
derivatives with respect to a specific parameter</p></li>
</ul>
<p>Note also that</p>
<ul class="simple">
<li><p>You can trade a longer construction time for faster evaluation time by
setting <code class="docutils literal notranslate"><span class="pre">component_model.lambdify</span></code> to
<code class="docutils literal notranslate"><span class="pre">sympy.utilities.autowrap.ufuncify</span></code>.
After constructing the anlytic component you can revert back the change by
setting <code class="docutils literal notranslate"><span class="pre">component_model.lambdify</span></code> back to <code class="docutils literal notranslate"><span class="pre">sympy.lambdify</span></code>.
The gain can negligible or considerable depending on the analytic
expression.</p></li>
</ul>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></dt><dd><p>Number of free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.CMB">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">CMB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K_CMB'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#CMB"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.CMB" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qcomponent_model.AnalyticComponent" title="lib.Qcomponent_model.AnalyticComponent"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticComponent</span></code></a></p>
<p>Cosmic microwave background</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>units</strong> – Output units (K_CMB and K_RJ available)</p>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></dt><dd><p>Number of free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Component">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">Component</span></span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#Component"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.Component" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Abstract class for SED evaluation</p>
<p>It defines the API.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#lib.Qcomponent_model.Component.defaults" title="lib.Qcomponent_model.Component.defaults"><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></a></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><a class="reference internal" href="#lib.Qcomponent_model.Component.n_param" title="lib.Qcomponent_model.Component.n_param"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></a></dt><dd><p>Number of free parameters</p>
</dd>
<dt><a class="reference internal" href="#lib.Qcomponent_model.Component.params" title="lib.Qcomponent_model.Component.params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></a></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qcomponent_model.Component.diff" title="lib.Qcomponent_model.Component.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qcomponent_model.Component.eval" title="lib.Qcomponent_model.Component.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Component.defaults">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">defaults</span></span><a class="headerlink" href="#lib.Qcomponent_model.Component.defaults" title="Link to this definition"></a></dt>
<dd><p>Default values of the free parameters</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Component.diff">
<span class="sig-name descname"><span class="pre">diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#Component.diff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.Component.diff" title="Link to this definition"></a></dt>
<dd><p>Evaluate the derivative of the SED</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nu</strong> (<em>array</em>) – Frequencies or banpasses for the SED evaluation
See the result of <code class="xref py py-func docutils literal notranslate"><span class="pre">bandpass_integration()</span></code>.</p></li>
<li><p><strong>*params</strong> (<em>float</em><em> or </em><em>ndarray</em>) – Value of the free parameters. They can be arrays and, in this case,
they should be broadcastable to a common shape.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – It contains the derivative with respect to each parameter. See
<a class="reference internal" href="#lib.Qcomponent_model.Component.eval" title="lib.Qcomponent_model.Component.eval"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eval()</span></code></a> for more details about the format of the
evaluated derivative</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Component.diff_diff">
<span class="sig-name descname"><span class="pre">diff_diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#Component.diff_diff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.Component.diff_diff" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Component.eval">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#Component.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.Component.eval" title="Link to this definition"></a></dt>
<dd><p>Evaluate the SED</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nu</strong> (<em>array</em><em>, </em><em>tuple</em><em> or </em><em>list</em>) – Frequencies or banpasses for the SED evaluation
See the result of <code class="xref py py-func docutils literal notranslate"><span class="pre">bandpass_integration()</span></code>.</p></li>
<li><p><strong>*params</strong> (<em>float</em><em> or </em><em>ndarray</em>) – Value of each of the free parameters. They can be arrays and, in
this case, they should be broadcastable to a common shape.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>result</strong> – SED. The shape is <code class="docutils literal notranslate"><span class="pre">np.broadcast(*params).shape</span> <span class="pre">+</span> <span class="pre">nu.shape</span></code>
(or broadcastable to it).
In particular, if the parameters are all floats, the shape is
<cite>nu.shape</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Component.n_param">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_param</span></span><a class="headerlink" href="#lib.Qcomponent_model.Component.n_param" title="Link to this definition"></a></dt>
<dd><p>Number of free parameters</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Component.params">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">params</span></span><a class="headerlink" href="#lib.Qcomponent_model.Component.params" title="Link to this definition"></a></dt>
<dd><p>Name of the free parameters</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Dust">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">Dust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta_d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K_CMB'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#Dust"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.Dust" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qcomponent_model.ModifiedBlackBody" title="lib.Qcomponent_model.ModifiedBlackBody"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModifiedBlackBody</span></code></a></p>
<p>Alias of <a class="reference internal" href="#lib.Qcomponent_model.ModifiedBlackBody" title="lib.Qcomponent_model.ModifiedBlackBody"><code class="xref py py-class docutils literal notranslate"><span class="pre">ModifiedBlackBody</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></dt><dd><p>Number of free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.FreeFree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">FreeFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logEM</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Te</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K_CMB'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#FreeFree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.FreeFree" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qcomponent_model.AnalyticComponent" title="lib.Qcomponent_model.AnalyticComponent"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticComponent</span></code></a></p>
<p>Free-free</p>
<p>Anlytic model for bremsstrahlung emission (Draine, 2011)
Above 1GHz it is essentially equivalent to a power law.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logEM</strong> – Logarithm (base ten) of the integrated squared electron density along a
line of sight in cm^-3 pc</p></li>
<li><p><strong>Te</strong> – Electron temperature</p></li>
<li><p><strong>units</strong> – Output units (K_CMB and K_RJ available)</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></dt><dd><p>Number of free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.ModifiedBlackBody">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">ModifiedBlackBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta_d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K_CMB'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#ModifiedBlackBody"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.ModifiedBlackBody" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qcomponent_model.AnalyticComponent" title="lib.Qcomponent_model.AnalyticComponent"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticComponent</span></code></a></p>
<p>Modified Black body</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nu0</strong> (<em>float</em>) – Reference frequency</p></li>
<li><p><strong>temp</strong> (<em>float</em>) – Black body temperature</p></li>
<li><p><strong>beta_d</strong> (<em>float</em>) – Spectral index</p></li>
<li><p><strong>units</strong> – Output units (K_CMB and K_RJ available)</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></dt><dd><p>Number of free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.PowerLaw">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">PowerLaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta_pl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_pivot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">running</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K_CMB'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#PowerLaw"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.PowerLaw" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qcomponent_model.AnalyticComponent" title="lib.Qcomponent_model.AnalyticComponent"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticComponent</span></code></a></p>
<p>Power law</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nu0</strong> (<em>float</em>) – Reference frequency</p></li>
<li><p><strong>beta_pl</strong> (<em>float</em>) – Spectral index</p></li>
<li><p><strong>nu_pivot</strong> (<em>float</em>) – Pivot frequency for the running</p></li>
<li><p><strong>running</strong> (<em>float</em>) – Curvature of the power law</p></li>
<li><p><strong>units</strong> – Output units (K_CMB and K_RJ available)</p></li>
</ul>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></dt><dd><p>Number of free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.Synchrotron">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">Synchrotron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta_pl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu_pivot</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">running</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K_CMB'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#Synchrotron"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.Synchrotron" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qcomponent_model.PowerLaw" title="lib.Qcomponent_model.PowerLaw"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerLaw</span></code></a></p>
<p>Alias of <a class="reference internal" href="#lib.Qcomponent_model.PowerLaw" title="lib.Qcomponent_model.PowerLaw"><code class="xref py py-class docutils literal notranslate"><span class="pre">PowerLaw</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></dt><dd><p>Number of free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qcomponent_model.ThermalSZ">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qcomponent_model.</span></span><span class="sig-name descname"><span class="pre">ThermalSZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">units</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'uK_CMB'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qcomponent_model.html#ThermalSZ"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qcomponent_model.ThermalSZ" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#lib.Qcomponent_model.AnalyticComponent" title="lib.Qcomponent_model.AnalyticComponent"><code class="xref py py-class docutils literal notranslate"><span class="pre">AnalyticComponent</span></code></a></p>
<p>Thermal Sunyaev-Zeldovich</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>units</strong> – Output units (K_CMB and K_RJ available)</p>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">defaults</span></code></dt><dd><p>Default values of the free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_param</span></code></dt><dd><p>Number of free parameters</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">params</span></code></dt><dd><p>Name of the free parameters</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code>(nu, *params)</p></td>
<td><p>Evaluate the derivative of the SED</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code>(nu, *params)</p></td>
<td><p>Evaluate the SED</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="module-lib.Qfit">
<span id="lib-qfit-module"></span><h2>lib.Qfit module<a class="headerlink" href="#module-lib.Qfit" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qfit.FitEllSpace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qfit.</span></span><span class="sig-name descname"><span class="pre">FitEllSpace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yerr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfit.html#FitEllSpace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfit.FitEllSpace" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>log_prior</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>loglikelihood</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>run</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qfit.FitEllSpace.log_prior">
<span class="sig-name descname"><span class="pre">log_prior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfit.html#FitEllSpace.log_prior"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfit.FitEllSpace.log_prior" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qfit.FitEllSpace.loglikelihood">
<span class="sig-name descname"><span class="pre">loglikelihood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfit.html#FitEllSpace.loglikelihood"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfit.FitEllSpace.loglikelihood" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qfit.FitEllSpace.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsteps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nwalkers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfit.html#FitEllSpace.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfit.FitEllSpace.run" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-lib.Qfoldertools">
<span id="lib-qfoldertools-module"></span><h2>lib.Qfoldertools module<a class="headerlink" href="#module-lib.Qfoldertools" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qfoldertools.MergeAllFiles">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qfoldertools.</span></span><span class="sig-name descname"><span class="pre">MergeAllFiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">foldername</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfoldertools.html#MergeAllFiles"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfoldertools.MergeAllFiles" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lib.Qfoldertools.create_folder_if_not_exists">
<span class="sig-prename descclassname"><span class="pre">lib.Qfoldertools.</span></span><span class="sig-name descname"><span class="pre">create_folder_if_not_exists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">folder_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfoldertools.html#create_folder_if_not_exists"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfoldertools.create_folder_if_not_exists" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lib.Qfoldertools.do_gif">
<span class="sig-prename descclassname"><span class="pre">lib.Qfoldertools.</span></span><span class="sig-name descname"><span class="pre">do_gif</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'animation.gif'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfoldertools.html#do_gif"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfoldertools.do_gif" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lib.Qfoldertools.open_data">
<span class="sig-prename descclassname"><span class="pre">lib.Qfoldertools.</span></span><span class="sig-name descname"><span class="pre">open_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfoldertools.html#open_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfoldertools.open_data" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lib.Qfoldertools.save_data">
<span class="sig-prename descclassname"><span class="pre">lib.Qfoldertools.</span></span><span class="sig-name descname"><span class="pre">save_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qfoldertools.html#save_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qfoldertools.save_data" title="Link to this definition"></a></dt>
<dd><p>Method to save data using pickle convention.</p>
</dd></dl>

</section>
<section id="module-lib.Qinstrument">
<span id="lib-qinstrument-module"></span><h2>lib.Qinstrument module<a class="headerlink" href="#module-lib.Qinstrument" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qinstrument.</span></span><span class="sig-name descname"><span class="pre">QubicInstrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FRBW</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Instrument</span></code></p>
<p>The QubicInstrument class. It represents the instrument setup.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>comm</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_aperture_integration_operator" title="lib.Qinstrument.QubicInstrument.get_aperture_integration_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_aperture_integration_operator</span></code></a>()</p></td>
<td><p>Integrate flux density in the telescope aperture.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_convolution_peak_operator" title="lib.Qinstrument.QubicInstrument.get_convolution_peak_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_convolution_peak_operator</span></code></a>(**keywords)</p></td>
<td><p>Return an operator that convolves the Healpix sky by the gaussian kernel that, if used in conjonction with the peak sampling operator, best approximates the synthetic beam.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_detector_integration_operator" title="lib.Qinstrument.QubicInstrument.get_detector_integration_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_detector_integration_operator</span></code></a>()</p></td>
<td><p>Integrate flux density in detector solid angles and take into account the secondary beam transmission.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_detector_response_operator" title="lib.Qinstrument.QubicInstrument.get_detector_response_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_detector_response_operator</span></code></a>(sampling[, tau])</p></td>
<td><p>Return the operator for the bolometer responses.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_filter_operator" title="lib.Qinstrument.QubicInstrument.get_filter_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_filter_operator</span></code></a>()</p></td>
<td><p>Return the filter operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_hwp_operator" title="lib.Qinstrument.QubicInstrument.get_hwp_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_hwp_operator</span></code></a>(sampling, scene)</p></td>
<td><p>Return the rotation matrix for the half-wave plate.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_invntt_operator" title="lib.Qinstrument.QubicInstrument.get_invntt_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_invntt_operator</span></code></a>(sampling)</p></td>
<td><p>Return the inverse time-time noise correlation matrix as an Operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_noise" title="lib.Qinstrument.QubicInstrument.get_noise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_noise</span></code></a>(sampling, scene[, det_noise, ...])</p></td>
<td><p>Return a noisy timeline.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_noise_detector" title="lib.Qinstrument.QubicInstrument.get_noise_detector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_noise_detector</span></code></a>(sampling[, out])</p></td>
<td><p>Return the detector noise (#det, #sampling).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_noise_photon" title="lib.Qinstrument.QubicInstrument.get_noise_photon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_noise_photon</span></code></a>(sampling, scene[, out])</p></td>
<td><p>Return the photon noise (#det, #sampling).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator</span></code>(sampling, scene)</p></td>
<td><p>Return the acquisition model for the specified sampling and scene as an operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_polarizer_operator" title="lib.Qinstrument.QubicInstrument.get_polarizer_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_polarizer_operator</span></code></a>(sampling, scene)</p></td>
<td><p>Return operator for the polarizer grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_projection_operator" title="lib.Qinstrument.QubicInstrument.get_projection_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_projection_operator</span></code></a>(sampling, scene[, ...])</p></td>
<td><p>Return the peak sampling operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_synthbeam" title="lib.Qinstrument.QubicInstrument.get_synthbeam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_synthbeam</span></code></a>(scene[, idet, theta_max, ...])</p></td>
<td><p>Return the detector synthetic beams, computed from the superposition of the electromagnetic fields.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qinstrument.QubicInstrument.get_transmission_operator" title="lib.Qinstrument.QubicInstrument.get_transmission_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_transmission_operator</span></code></a>()</p></td>
<td><p>Return the operator that multiplies by the cumulative instrumental transmission.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pack</span></code>(x)</p></td>
<td><p>Convert a multi-dimensional array into a 1-dimensional array which only includes the selected components, potentially ordered according to a given ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>(**keywords)</p></td>
<td><p>Plot the instrument detector footprint.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scatter</span></code>([comm])</p></td>
<td><p>MPI-scatter of the instrument.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(n)</p></td>
<td><p>Split the instrument in partitioning groups.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unpack</span></code>(x)</p></td>
<td><p>Convert a 1-dimensional array into a multi-dimensional array which includes the non-selected components, mimicking the multi-dimensional layout.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>detector_subset</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.detector_subset">
<span class="sig-name descname"><span class="pre">detector_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dets</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.detector_subset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.detector_subset" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_aperture_integration_operator">
<span class="sig-name descname"><span class="pre">get_aperture_integration_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_aperture_integration_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_aperture_integration_operator" title="Link to this definition"></a></dt>
<dd><p>Integrate flux density in the telescope aperture.
Convert signal from W / m^2 / Hz into W / Hz.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_convolution_peak_operator">
<span class="sig-name descname"><span class="pre">get_convolution_peak_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_convolution_peak_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_convolution_peak_operator" title="Link to this definition"></a></dt>
<dd><p>Return an operator that convolves the Healpix sky by the gaussian
kernel that, if used in conjonction with the peak sampling operator,
best approximates the synthetic beam.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_detector_integration_operator">
<span class="sig-name descname"><span class="pre">get_detector_integration_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_detector_integration_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_detector_integration_operator" title="Link to this definition"></a></dt>
<dd><p>Integrate flux density in detector solid angles and take into account
the secondary beam transmission.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_detector_response_operator">
<span class="sig-name descname"><span class="pre">get_detector_response_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_detector_response_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_detector_response_operator" title="Link to this definition"></a></dt>
<dd><p>Return the operator for the bolometer responses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_filter_operator">
<span class="sig-name descname"><span class="pre">get_filter_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_filter_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_filter_operator" title="Link to this definition"></a></dt>
<dd><p>Return the filter operator.
Convert units from W/Hz to W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_hwp_operator">
<span class="sig-name descname"><span class="pre">get_hwp_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_hwp_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_hwp_operator" title="Link to this definition"></a></dt>
<dd><p>Return the rotation matrix for the half-wave plate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_invntt_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_invntt_operator" title="Link to this definition"></a></dt>
<dd><p>Return the inverse time-time noise correlation matrix as an Operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_noise">
<span class="sig-name descname"><span class="pre">get_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_noise=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">photon_noise=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operation=&lt;function</span> <span class="pre">operation_assignment&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_noise" title="Link to this definition"></a></dt>
<dd><p>Return a noisy timeline.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_noise_detector">
<span class="sig-name descname"><span class="pre">get_noise_detector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_noise_detector"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_noise_detector" title="Link to this definition"></a></dt>
<dd><p>Return the detector noise (#det, #sampling).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_noise_photon">
<span class="sig-name descname"><span class="pre">get_noise_photon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_noise_photon"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_noise_photon" title="Link to this definition"></a></dt>
<dd><p>Return the photon noise (#det, #sampling).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_polarizer_operator">
<span class="sig-name descname"><span class="pre">get_polarizer_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_polarizer_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_polarizer_operator" title="Link to this definition"></a></dt>
<dd><p>Return operator for the polarizer grid.
When the polarizer is not present a transmission of 1 is assumed
for the detectors on the first focal plane and of 0 for the other.
Otherwise, the signal is split onto the focal planes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_projection_operator">
<span class="sig-name descname"><span class="pre">get_projection_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_projection_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_projection_operator" title="Link to this definition"></a></dt>
<dd><p>Return the peak sampling operator.
Convert units from W to W/sr.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sampling</strong> (<em>QubicSampling</em>) – The pointing information.</p></li>
<li><p><strong>scene</strong> (<em>QubicScene</em>) – The observed scene.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, display information about the memory allocation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_synthbeam">
<span class="sig-name descname"><span class="pre">get_synthbeam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwp_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detpos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_synthbeam"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_synthbeam" title="Link to this definition"></a></dt>
<dd><p>Return the detector synthetic beams, computed from the superposition
of the electromagnetic fields.</p>
<p>The synthetic beam B_d = (B_d,i) of a given detector d is such that
the power I_d in [W] collected by this detector observing a sky S=(S_i)
in [W/m^2/Hz] is:</p>
<blockquote>
<div><p>I_d = (S | B_d) = sum_i S_i * B_d,i.</p>
</div></blockquote>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scene</span> <span class="o">=</span> <span class="n">QubicScene</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inst</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">get_synthbeam</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The power collected by the bolometers in W, given a sky in W/m²/Hz is:
&gt;&gt;&gt; sb = inst.get_synthbeam(scene)
&gt;&gt;&gt; sky = scene.ones()   # [W/m²/Hz]
&gt;&gt;&gt; P = np.dot(sb, sky)  # [W]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scene</strong> (<em>QubicScene</em>) – The scene.</p></li>
<li><p><strong>idet</strong> (<em>int</em><em>, </em><em>optional</em>) – The detector number. By default, the synthetic beam is computed for
all detectors.</p></li>
<li><p><strong>theta_max</strong> (<em>float</em><em>, </em><em>optional</em>) – The maximum zenithal angle above which the synthetic beam is
assumed to be zero, in degrees.</p></li>
<li><p><strong>external_A</strong> (<em>list</em><em> of </em><em>tables describing the phase and amplitude at each point</em><em> of </em><em>the focal</em>) – plane for each of the horns:
[0] : array, X coordinates with shape (n) in GRF [m]
[1] : array, Y coordinates with shape (n) in GRF [m]
[2] : array, amplitude on X with shape (n, nhorns)
[3] : array, amplitude on Y with shape (n, nhorns)
[4] : array, phase on X with shape (n, nhorns) [rad]
[5] : array, phase on Y with shape (n, nhorns) [rad]</p></li>
<li><p><strong>hwp_position</strong> (<em>int</em>) – HWP position from 0 to 7.</p></li>
<li><p><strong>detector_integrate</strong> (<em>Optional</em><em>, </em><em>number</em><em> of </em><em>subpixels in x direction for integration over detectors</em>) – default (None) is no integration =&gt; uses the center of the pixel</p></li>
<li><p><strong>detpos</strong> (<em>Optional</em><em>, </em><em>position in the focal plane at which the Synthesized Beam is desired as np.array</em><em>(</em><em>[</em><em>x</em><em>,</em><em>y</em><em>,</em><em>z</em><em>]</em><em>)</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicInstrument.get_transmission_operator">
<span class="sig-name descname"><span class="pre">get_transmission_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicInstrument.get_transmission_operator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicInstrument.get_transmission_operator" title="Link to this definition"></a></dt>
<dd><p>Return the operator that multiplies by the cumulative instrumental
transmission.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicMultibandInstrument">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qinstrument.</span></span><span class="sig-name descname"><span class="pre">QubicMultibandInstrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicMultibandInstrument"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicMultibandInstrument" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The QubicMultibandInstrument class
Represents the QUBIC multiband features
as an array of QubicInstrumet objects</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>detector_subset</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>direct_convolution</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_synthbeam</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicMultibandInstrument.detector_subset">
<span class="sig-name descname"><span class="pre">detector_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dets</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicMultibandInstrument.detector_subset"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicMultibandInstrument.detector_subset" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicMultibandInstrument.direct_convolution">
<span class="sig-name descname"><span class="pre">direct_convolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicMultibandInstrument.direct_convolution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicMultibandInstrument.direct_convolution" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qinstrument.QubicMultibandInstrument.get_synthbeam">
<span class="sig-name descname"><span class="pre">get_synthbeam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detpos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qinstrument.html#QubicMultibandInstrument.get_synthbeam"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qinstrument.QubicMultibandInstrument.get_synthbeam" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-lib.Qmap_plotter">
<span id="lib-qmap-plotter-module"></span><h2>lib.Qmap_plotter module<a class="headerlink" href="#module-lib.Qmap_plotter" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qmap_plotter.Plots">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qmap_plotter.</span></span><span class="sig-name descname"><span class="pre">Plots</span></span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#Plots"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.Plots" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Instance for plotting results of Monte-Carlo Markov Chain (i.e emcee).</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qmap_plotter.Plots.get_convergence" title="lib.Qmap_plotter.Plots.get_convergence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_convergence</span></code></a>(chain, job_id)</p></td>
<td><p>chain assumed to be not flat with shape (nsamples, nwalkers, nparams)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qmap_plotter.Plots.get_triangle" title="lib.Qmap_plotter.Plots.get_triangle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_triangle</span></code></a>(chain, names, labels, job_id)</p></td>
<td><p>Make triangle plot of each estimated parameters</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qmap_plotter.Plots.make_list_free_parameter" title="lib.Qmap_plotter.Plots.make_list_free_parameter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_list_free_parameter</span></code></a>()</p></td>
<td><p>Make few list :</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>get_Dl_plot</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.Plots.get_Dl_plot">
<span class="sig-name descname"><span class="pre">get_Dl_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dl_err</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">job_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(10,</span> <span class="pre">10)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#Plots.get_Dl_plot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.Plots.get_Dl_plot" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.Plots.get_convergence">
<span class="sig-name descname"><span class="pre">get_convergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">job_id</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#Plots.get_convergence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.Plots.get_convergence" title="Link to this definition"></a></dt>
<dd><p>chain assumed to be not flat with shape (nsamples, nwalkers, nparams)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.Plots.get_triangle">
<span class="sig-name descname"><span class="pre">get_triangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">job_id</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#Plots.get_triangle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.Plots.get_triangle" title="Link to this definition"></a></dt>
<dd><p>Make triangle plot of each estimated parameters</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.Plots.make_list_free_parameter">
<span class="sig-name descname"><span class="pre">make_list_free_parameter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#Plots.make_list_free_parameter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.Plots.make_list_free_parameter" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Make few list :</dt><dd><ul class="simple">
<li><p>fp       : list of value of free parameters</p></li>
<li><p>fp_name  : list of name for each values</p></li>
<li><p>fp_latex : list of name in LateX for each values</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsCMM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qmap_plotter.</span></span><span class="sig-name descname"><span class="pre">PlotsCMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">preset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dogif</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsCMM"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsCMM" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Instance to produce plots on the convergence.</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qmap_plotter.PlotsCMM.display_maps" title="lib.Qmap_plotter.PlotsCMM.display_maps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">display_maps</span></code></a>(seenpix[, figsize, nsig, ki, view])</p></td>
<td><p>Method to display maps at given iteration.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qmap_plotter.PlotsCMM.plot_beta_iteration" title="lib.Qmap_plotter.PlotsCMM.plot_beta_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_beta_iteration</span></code></a>(beta[, figsize, truth, ki])</p></td>
<td><p>Method to plot beta as a function of iteration.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qmap_plotter.PlotsCMM.plot_gain_iteration" title="lib.Qmap_plotter.PlotsCMM.plot_gain_iteration"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_gain_iteration</span></code></a>(gain[, figsize, ki])</p></td>
<td><p>Method to plot convergence of reconstructed gains.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qmap_plotter.PlotsCMM.plot_sed" title="lib.Qmap_plotter.PlotsCMM.plot_sed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_sed</span></code></a>(nus_in, A_in, nus_out, A_out[, ...])</p></td>
<td><p>Plots the Spectral Energy Distribution (SED) and saves the plot as a PNG file.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>plot_rms_iteration</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsCMM.display_maps">
<span class="sig-name descname"><span class="pre">display_maps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seenpix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(14,</span> <span class="pre">8)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ki</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gnomview'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsCMM.display_maps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsCMM.display_maps" title="Link to this definition"></a></dt>
<dd><p>Method to display maps at given iteration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsCMM.plot_beta_iteration">
<span class="sig-name descname"><span class="pre">plot_beta_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">truth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ki</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsCMM.plot_beta_iteration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsCMM.plot_beta_iteration" title="Link to this definition"></a></dt>
<dd><p>Method to plot beta as a function of iteration. Beta can have shape (niter) or (niter, nbeta).</p>
<p>Parameters:
beta : numpy.ndarray</p>
<blockquote>
<div><p>Array containing beta values for each iteration. Can be 1D or 2D.</p>
</div></blockquote>
<dl class="simple">
<dt>figsize<span class="classifier">tuple, optional</span></dt><dd><p>Size of the figure to be plotted. Default is (8, 6).</p>
</dd>
<dt>truth<span class="classifier">numpy.ndarray or float, optional</span></dt><dd><p>True value(s) of beta to be plotted as a reference line. Default is None.</p>
</dd>
<dt>ki<span class="classifier">int, optional</span></dt><dd><p>Iteration index for saving the plot. Default is 0.</p>
</dd>
</dl>
<p>Returns:
None</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsCMM.plot_gain_iteration">
<span class="sig-name descname"><span class="pre">plot_gain_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ki</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsCMM.plot_gain_iteration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsCMM.plot_gain_iteration" title="Link to this definition"></a></dt>
<dd><p>Method to plot convergence of reconstructed gains.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsCMM.plot_rms_iteration">
<span class="sig-name descname"><span class="pre">plot_rms_iteration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ki</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsCMM.plot_rms_iteration"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsCMM.plot_rms_iteration" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsCMM.plot_sed">
<span class="sig-name descname"><span class="pre">plot_sed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nus_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nus_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ki</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gif</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsCMM.plot_sed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsCMM.plot_sed" title="Link to this definition"></a></dt>
<dd><p>Plots the Spectral Energy Distribution (SED) and saves the plot as a PNG file.</p>
<p>Parameters:
nus (array-like): Array of frequency values.
A (array-like): Array of amplitude values.
figsize (tuple, optional): Size of the figure. Defaults to (8, 6).
truth (array-like, optional): Array of true values for comparison. Defaults to None.
ki (int, optional): Iteration index for file naming. Defaults to 0.</p>
<p>Returns:
None</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsFMM">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qmap_plotter.</span></span><span class="sig-name descname"><span class="pre">PlotsFMM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seenpix</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsFMM"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsFMM" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>plot_FMM_mollview</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>plot_FMM_old</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>plot_frequency_maps</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsFMM.plot_FMM_mollview">
<span class="sig-name descname"><span class="pre">plot_FMM_mollview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">job_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(10,</span> <span class="pre">8)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">istk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsFMM.plot_FMM_mollview"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsFMM.plot_FMM_mollview" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsFMM.plot_FMM_old">
<span class="sig-name descname"><span class="pre">plot_FMM_old</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seenpix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">job_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(10,</span> <span class="pre">8)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">istk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'signal'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsFMM.plot_FMM_old"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsFMM.plot_FMM_old" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmap_plotter.PlotsFMM.plot_frequency_maps">
<span class="sig-name descname"><span class="pre">plot_frequency_maps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reso</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(10,</span> <span class="pre">8)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmap_plotter.html#PlotsFMM.plot_frequency_maps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmap_plotter.PlotsFMM.plot_frequency_maps" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-lib.Qmixing_matrix">
<span id="lib-qmixing-matrix-module"></span><h2>lib.Qmixing_matrix module<a class="headerlink" href="#module-lib.Qmixing_matrix" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qmixing_matrix.</span></span><span class="sig-name descname"><span class="pre">MixingMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">components</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmixing_matrix.html#MixingMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
<p>Collection of Components
The goal is to provide ways to evaluate all the components (or their
derivatives) with a single call and store them in a matrix (the mixing
matrix).
There are two ways:
- evaluate it using (nu, param_0, param_1, param_2, …)
- provide A_ev, which takes a single array as argument</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>comp_of_dB</strong></dt><dd></dd>
<dt><strong>components</strong></dt><dd></dd>
<dt><strong>defaults</strong></dt><dd></dd>
<dt><strong>n_param</strong></dt><dd></dd>
<dt><strong>params</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code>(value, /)</p></td>
<td><p>Return number of occurrences of value.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code>(value[, start, stop])</p></td>
<td><p>Return first index of value.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>diff</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>diff_diff</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>diff_diff_evaluator</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>diff_evaluator</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>eval</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>evaluator</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.comp_of_dB">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">comp_of_dB</span></span><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.comp_of_dB" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.components">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">components</span></span><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.components" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.defaults">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">defaults</span></span><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.defaults" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.diff">
<span class="sig-name descname"><span class="pre">diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmixing_matrix.html#MixingMatrix.diff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.diff" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.diff_diff">
<span class="sig-name descname"><span class="pre">diff_diff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmixing_matrix.html#MixingMatrix.diff_diff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.diff_diff" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.diff_diff_evaluator">
<span class="sig-name descname"><span class="pre">diff_diff_evaluator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unpack=&lt;function</span> <span class="pre">MixingMatrix.&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmixing_matrix.html#MixingMatrix.diff_diff_evaluator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.diff_diff_evaluator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.diff_evaluator">
<span class="sig-name descname"><span class="pre">diff_evaluator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unpack=&lt;function</span> <span class="pre">MixingMatrix.&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmixing_matrix.html#MixingMatrix.diff_evaluator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.diff_evaluator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.eval">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmixing_matrix.html#MixingMatrix.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.eval" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.evaluator">
<span class="sig-name descname"><span class="pre">evaluator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unpack=&lt;function</span> <span class="pre">MixingMatrix.&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmixing_matrix.html#MixingMatrix.evaluator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.evaluator" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.n_param">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_param</span></span><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.n_param" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="lib.Qmixing_matrix.MixingMatrix.params">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">params</span></span><a class="headerlink" href="#lib.Qmixing_matrix.MixingMatrix.params" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-lib.Qmpi_tools">
<span id="lib-qmpi-tools-module"></span><h2>lib.Qmpi_tools module<a class="headerlink" href="#module-lib.Qmpi_tools" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="lib.Qmpi_tools.join_data">
<span class="sig-prename descclassname"><span class="pre">lib.Qmpi_tools.</span></span><span class="sig-name descname"><span class="pre">join_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmpi_tools.html#join_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmpi_tools.join_data" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lib.Qmpi_tools.join_toward_rank">
<span class="sig-prename descclassname"><span class="pre">lib.Qmpi_tools.</span></span><span class="sig-name descname"><span class="pre">join_toward_rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_rank</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmpi_tools.html#join_toward_rank"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmpi_tools.join_toward_rank" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="lib.Qmpi_tools.split_data">
<span class="sig-prename descclassname"><span class="pre">lib.Qmpi_tools.</span></span><span class="sig-name descname"><span class="pre">split_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qmpi_tools.html#split_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qmpi_tools.split_data" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-lib.Qnoise">
<span id="lib-qnoise-module"></span><h2>lib.Qnoise module<a class="headerlink" href="#module-lib.Qnoise" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qnoise.QubicDualBandNoise">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qnoise.</span></span><span class="sig-name descname"><span class="pre">QubicDualBandNoise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npointings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_nep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.7e-17</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[3,</span> <span class="pre">3]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicDualBandNoise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicDualBandNoise" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>total_noise</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qnoise.QubicDualBandNoise.total_noise">
<span class="sig-name descname"><span class="pre">total_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wdet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wpho150</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wpho220</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicDualBandNoise.total_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicDualBandNoise.total_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qnoise.QubicNoise">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qnoise.</span></span><span class="sig-name descname"><span class="pre">QubicNoise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">band</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npointings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_nep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.7e-17</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicNoise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicNoise" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>detector_noise</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>get_noise</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>photon_noise</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>total_noise</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qnoise.QubicNoise.detector_noise">
<span class="sig-name descname"><span class="pre">detector_noise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicNoise.detector_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicNoise.detector_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qnoise.QubicNoise.get_noise">
<span class="sig-name descname"><span class="pre">get_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">det_noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pho_noise</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicNoise.get_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicNoise.get_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qnoise.QubicNoise.photon_noise">
<span class="sig-name descname"><span class="pre">photon_noise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicNoise.photon_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicNoise.photon_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qnoise.QubicNoise.total_noise">
<span class="sig-name descname"><span class="pre">total_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wdet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wpho</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicNoise.total_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicNoise.total_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qnoise.QubicWideBandNoise">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qnoise.</span></span><span class="sig-name descname"><span class="pre">QubicWideBandNoise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npointings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_nep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.7e-17</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">duration</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicWideBandNoise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicWideBandNoise" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>total_noise</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qnoise.QubicWideBandNoise.total_noise">
<span class="sig-name descname"><span class="pre">total_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wdet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wpho150</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wpho220</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qnoise.html#QubicWideBandNoise.total_noise"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qnoise.QubicWideBandNoise.total_noise" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-lib.Qspectra">
<span id="lib-qspectra-module"></span><h2>lib.Qspectra module<a class="headerlink" href="#module-lib.Qspectra" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qspectra.Spectra">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qspectra.</span></span><span class="sig-name descname"><span class="pre">Spectra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectra" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>open_file</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>run</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectra.open_file">
<span class="sig-name descname"><span class="pre">open_file</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectra.open_file"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectra.open_file" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectra.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectra.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectra.run" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qspectra.</span></span><span class="sig-name descname"><span class="pre">Spectrumold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class to compute the different spectra for our realisations</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qspectra.Spectrumold.compute_array_power_spectra" title="lib.Qspectra.Spectrumold.compute_array_power_spectra"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_array_power_spectra</span></code></a>(maps)</p></td>
<td><p>Function to fill an array with all the power spectra computed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qspectra.Spectrumold.compute_auto_spectrum" title="lib.Qspectra.Spectrumold.compute_auto_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_auto_spectrum</span></code></a>(map, fwhm)</p></td>
<td><p>Function to compute the auto-spectrum of a given map</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qspectra.Spectrumold.compute_cross_spectrum" title="lib.Qspectra.Spectrumold.compute_cross_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cross_spectrum</span></code></a>(map1, fwhm1, map2, fwhm2)</p></td>
<td><p>Function to compute cross-spectrum, taking into account the different resolution of each sub-bands</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qspectra.Spectrumold.compute_power_spectra" title="lib.Qspectra.Spectrumold.compute_power_spectra"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_power_spectra</span></code></a>()</p></td>
<td><p>Function to compute the power spectra array for the sky and for the noise realisations</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qspectra.Spectrumold.get_dict" title="lib.Qspectra.Spectrumold.get_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dict</span></code></a>()</p></td>
<td><p>Method to modify the qubic dictionary.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qspectra.Spectrumold.get_ultrawideband_config" title="lib.Qspectra.Spectrumold.get_ultrawideband_config"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ultrawideband_config</span></code></a>()</p></td>
<td><p>Method that pre-compute UWB configuration.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qspectra.Spectrumold.save_data" title="lib.Qspectra.Spectrumold.save_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_data</span></code></a>(name, d)</p></td>
<td><p>Method to save data using pickle convention.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>run</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold.compute_array_power_spectra">
<span class="sig-name descname"><span class="pre">compute_array_power_spectra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold.compute_array_power_spectra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold.compute_array_power_spectra" title="Link to this definition"></a></dt>
<dd><p>Function to fill an array with all the power spectra computed</p>
<dl class="simple">
<dt>Argument :</dt><dd><ul class="simple">
<li><p>maps (array [nreal, nrec/ncomp, npix, nstokes]) : all your realisation maps</p></li>
</ul>
</dd>
<dt>Return :</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>power_spectra_array (array [nrec/ncomp, nrec/ncomp])<span class="classifier">element [i, i] is the auto-spectrum for the reconstructed sub-bands i</span></dt><dd><p>element [i, j] is the cross-spectrum between the reconstructed sub-band i &amp; j</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold.compute_auto_spectrum">
<span class="sig-name descname"><span class="pre">compute_auto_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold.compute_auto_spectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold.compute_auto_spectrum" title="Link to this definition"></a></dt>
<dd><p>Function to compute the auto-spectrum of a given map</p>
<dl class="simple">
<dt>Argument :</dt><dd><ul class="simple">
<li><p>map(array) [nrec/ncomp, npix, nstokes] : map to compute the auto-spectrum</p></li>
<li><p>allfwhm(float) : in radian</p></li>
</ul>
</dd>
<dt>Return :</dt><dd><ul class="simple">
<li><p>(list) [len(ell)] : BB auto-spectrum</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold.compute_cross_spectrum">
<span class="sig-name descname"><span class="pre">compute_cross_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fwhm2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold.compute_cross_spectrum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold.compute_cross_spectrum" title="Link to this definition"></a></dt>
<dd><p>Function to compute cross-spectrum, taking into account the different resolution of each sub-bands</p>
<dl class="simple">
<dt>Arguments :</dt><dd><ul class="simple">
<li><p>map1 &amp; map2 (array [nrec/ncomp, npix, nstokes]) : the two maps needed to compute the cross spectrum</p></li>
<li><p>fwhm1 &amp; fwhm2 (float) : the respective fwhm for map1 &amp; map2 in radian</p></li>
</ul>
</dd>
<dt>Return :</dt><dd><ul class="simple">
<li><p>(list) [len(ell)] : BB cross-spectrum</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold.compute_power_spectra">
<span class="sig-name descname"><span class="pre">compute_power_spectra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold.compute_power_spectra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold.compute_power_spectra" title="Link to this definition"></a></dt>
<dd><p>Function to compute the power spectra array for the sky and for the noise realisations</p>
<dl class="simple">
<dt>Return :</dt><dd><ul class="simple">
<li><p>sky power spectra array (array [nrec/ncomp, nrec/ncomp])</p></li>
<li><p>noise power spectra array (array [nrec/ncomp, nrec/ncomp])</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold.get_dict">
<span class="sig-name descname"><span class="pre">get_dict</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold.get_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold.get_dict" title="Link to this definition"></a></dt>
<dd><p>Method to modify the qubic dictionary.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold.get_ultrawideband_config">
<span class="sig-name descname"><span class="pre">get_ultrawideband_config</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold.get_ultrawideband_config"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold.get_ultrawideband_config" title="Link to this definition"></a></dt>
<dd><p>Method that pre-compute UWB configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold.run" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra.Spectrumold.save_data">
<span class="sig-name descname"><span class="pre">save_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra.html#Spectrumold.save_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra.Spectrumold.save_data" title="Link to this definition"></a></dt>
<dd><p>Method to save data using pickle convention.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-lib.Qspectra_component">
<span id="lib-qspectra-component-module"></span><h2>lib.Qspectra_component module<a class="headerlink" href="#module-lib.Qspectra_component" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Qspectra_component.SkySpectra">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Qspectra_component.</span></span><span class="sig-name descname"><span class="pre">SkySpectra</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu0_d</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">353</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu0_s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">23</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra_component.html#SkySpectra"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra_component.SkySpectra" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qspectra_component.SkySpectra.cl_to_dl" title="lib.Qspectra_component.SkySpectra.cl_to_dl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cl_to_dl</span></code></a>(cl)</p></td>
<td><p>Function to convert the cls into the dls</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qspectra_component.SkySpectra.model_cmb" title="lib.Qspectra_component.SkySpectra.model_cmb"><code class="xref py py-obj docutils literal notranslate"><span class="pre">model_cmb</span></code></a>(r, Alens)</p></td>
<td><p>Define the CMB model, depending on r and Alens</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Qspectra_component.SkySpectra.scale_dust" title="lib.Qspectra_component.SkySpectra.scale_dust"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_dust</span></code></a>(betad[, temp])</p></td>
<td><p>Function to compute the dust mixing matrix element, depending on the frequency</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Qspectra_component.SkySpectra.scale_sync" title="lib.Qspectra_component.SkySpectra.scale_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_sync</span></code></a>(betas)</p></td>
<td><p>Function to compute the dust mixing matrix element, depending on the frequency</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>model</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>scale_dustsync</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra_component.SkySpectra.cl_to_dl">
<span class="sig-name descname"><span class="pre">cl_to_dl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cl</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra_component.html#SkySpectra.cl_to_dl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra_component.SkySpectra.cl_to_dl" title="Link to this definition"></a></dt>
<dd><p>Function to convert the cls into the dls</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra_component.SkySpectra.model">
<span class="sig-name descname"><span class="pre">model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Alens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">betad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">As</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alphas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">betas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra_component.html#SkySpectra.model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra_component.SkySpectra.model" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra_component.SkySpectra.model_cmb">
<span class="sig-name descname"><span class="pre">model_cmb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Alens</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra_component.html#SkySpectra.model_cmb"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra_component.SkySpectra.model_cmb" title="Link to this definition"></a></dt>
<dd><p>Define the CMB model, depending on r and Alens</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra_component.SkySpectra.scale_dust">
<span class="sig-name descname"><span class="pre">scale_dust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">betad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra_component.html#SkySpectra.scale_dust"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra_component.SkySpectra.scale_dust" title="Link to this definition"></a></dt>
<dd><p>Function to compute the dust mixing matrix element, depending on the frequency</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra_component.SkySpectra.scale_dustsync">
<span class="sig-name descname"><span class="pre">scale_dustsync</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">betad</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">betas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra_component.html#SkySpectra.scale_dustsync"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra_component.SkySpectra.scale_dustsync" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Qspectra_component.SkySpectra.scale_sync">
<span class="sig-name descname"><span class="pre">scale_sync</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">betas</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lib/Qspectra_component.html#SkySpectra.scale_sync"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#lib.Qspectra_component.SkySpectra.scale_sync" title="Link to this definition"></a></dt>
<dd><p>Function to compute the dust mixing matrix element, depending on the frequency</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-lib">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-lib" title="Link to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Mathias Regnier &amp; Tom Laclavère.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>